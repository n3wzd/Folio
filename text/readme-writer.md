# Writer

---

2024-02 ~ 2024-04 (1인)

## 배경
Writer는 실시간으로 Markdown 텍스트를 편집하고 HTML 형식으로 변환할 수 있는 편리한 텍스트 편집기입니다. 사용자가 작성하는 동안 Markdown 패턴이 실시간으로 분석되고 UI에 반영되어 더 효율적인 작업이 가능합니다. 또한, 파일 생성, 이름 변경, 삭제 등 문서 및 폴더 관리 기능을 제공하며, 작성된 텍스트는 MD 또는 HTML 형식으로 저장할 수 있습니다.

## 기능
- Markdown 텍스트 작성 
- 실시간 편집기, HTML 뷰어 업데이트
- 편집 상태 되돌리기, 복구하기
- 여러 텍스트 파일 저장
- 텍스트 파일 생성, 폴더 생성, 이름 변경, 파일 삭제
- 텍스트 파일 MD 또는 HTML 파일로 저장하기
- MD, TEXT 파일 불러오기

## Stack
- React

## 문제 및 해결
### 마크다운 텍스트 분석
이 프로젝트의 목표는 웹 환경에서 사용자가 입력한 텍스트를 분석하여 마크다운 패턴을 찾아내고, 입력 텍스트에 스타일을 추가하며, HTML 미리보기 페이지를 생성하는 것입니다. 우선, 사용자가 입력한 텍스트를 가져와야 하는 문제가 있습니다.

이 문제는 HTML 태그인 `<div contentEditable=true>`를 사용하여 해결할 수 있습니다.`contentEditable` 속성은 HTML 요소에 텍스트 편집 기능을 추가합니다. 이 속성을 사용하면 `<div>` 내부의 내용을 사용자가 직접 편집할 수 있는 상태로 만들어줍니다. 즉, 사용자는 이 `<div>` 영역에 마치 메모장이나 텍스트 편집기처럼 글을 입력하고 수정할 수 있습니다. `innerText` 속성을 통해 줄바꿈을 포함한 사용자의 입력 텍스트를 쉽게 가져올 수 있습니다.

다음으로 마크다운 패턴의 분석 과정과 이를 적용하는 과정을 설계해야 합니다. 분석을 통해 마크다운 패턴 데이터를 찾았고 이를 텍스트 에디터와 HTML 미리보기 페이지에 적용하기 위한 방법을 고려해보았습니다. 처음에는 React 컴포넌트를 추가하려 했으나, 추가할 때마다 리렌더링이 발생하여 입력 상태가 초기화되므로 사용할 수 없었습니다. 그리고 HTML 페이지를 출력하기 위해 `innerHTML` 사용을 고려해보았으나, XSS(Cross-Site Scripting) 공격에 취약할 수 있다는 보안 문제로 인해 사용하지 않기로 했습니다. 최종적으로 DOM API를 활용한 텍스트 에디터에 제공할 전체 텍스트, HTML 미리보기 페이지에 제공할 전체 텍스트를 생성하기로 했습니다.

전체적인 과정은 다음과 같습니다.
1. 입력 텍스트 분석: 입력된 텍스트를 분석하여 마크다운 패턴을 찾습니다.
2. 스타일 태그 삽입: 패턴 데이터를 기반으로 입력된 텍스트에 span 태그를 삽입하여 스타일을 적용합니다.
3. HTML 페이지 생성: 패턴 데이터를 기반으로 HTML 페이지 텍스트를 생성하여 결과를 시각화합니다.

다음으로 텍스트의 마크다운 패턴을 분석해야 합니다. 이를 지원하는 여러 외부 패키지가 있지만, 유연한 적용과 확장성을 위해 분석 알고리즘을 직접 구현해보기로 했습니다.

#### paragrah
입력 텍스트에는 개행이 포함될 수 있으므로, 출력 텍스트에 개행을 반영해야 합니다. 그러나 텍스트 에디터에서 개행 문자를 그대로 사용하면 정상적으로 개행이 되지 않는 문제가 발생합니다. 또한 HTML 페이지에서 개행이 여러 번 되면 시각적으로 불편하다는 문제가 있습니다. 따라서 개행을 정상적으로 반영해야 하고, 여러 번 개행이 되는 경우를 처리해야 합니다.

먼저 텍스트 에디터의 문제를 해결해봅시다. 브라우저 개발자 도구를 사용해 텍스트 개행 방식을 분석한 결과, 텍스트의 모든 줄이 `div`로 감싸져 있는 것을 확인했습니다. 따라서 모든 줄을 `div` 태그로 둘러싸서 반환하면 문제를 해결할 수 있을 것입니다. 단, 줄의 내용이 없는 경우가 존재할 수 있는데, 이 때는 `br` 태그를 삽입하여 반환하면 빈 줄의 개행을 반영할 수 있습니다. 모든 줄을 `div`로 둘러싸서 반환한 결과, 개행이 정상적으로 반영되었습니다. 

그 다음으로 HTML 페이지의 문제를 해결해봅시다. 1번의 개행은 반영해야 하지만, 개행이 2번 이상 일어나는 경우는 모두 개행이 1번으로 맞춰야 합니다. 이 문제를 해결하기 위해 `p` 태그를 활용하기로 했습니다. 개행 2번 이상이 발생하는 위치를 기준으로 텍스트를 단락으로 분할한 다음, 단락을 `p` 태그로 감싸면 됩니다. 단락 내부에서 개행이 발생할 수도 있는데, 이 경우엔 `p` 태그 내부에서 줄바꿈 태그 `br`을 삽입하면 됩니다.

이와 같은 방식으로 텍스트 에디터와 HTML 페이지의 개행 문제를 성공적으로 해결할 수 있었습니다.

#### 문자 단위 매칭 패턴
마크다운 패턴 중에는 두 개의 특정 문자열이 쌍을 이루는 구조를 가진 패턴이 있으며, 그 예로는 `del`, `strong`, `em`, `sup`, `sub`가 있습니다.

예를 들어, 강조 패턴은 다음과 같이 구성됩니다.
```
**이 문자열이 강조됩니다.**
```

이 패턴을 구현하기 위해 특징을 분석하였습니다.
- 두 개의 쌍이 모두 존재해야 패턴이 매칭됩니다. 1개만 존재하면 매칭되지 않습니다.
- 각 패턴들은 서로 중첩될 수 있습니다. 예를 들어 `del` 내부에 `strong`이 적용될 수 있습니다.

이 문제를 해결하기 위해 `스택` 자료구조를 활용하였습니다. 먼저 문자열 하나를 순차적으로 분석합니다. 그리고 매칭되는 패턴의 일부(예: `**`, `~~`)가 발견되면 스택에 해당 패턴이 존재하는지 원소를 꺼내보며 순차적으로 확인합니다. 만약 존재한다면 찾은 패턴을 마크다운 패턴에 반영합니다. 그렇지 않으면 스택을 원래대로 복구하고 해당 패턴의 일부를 스택에 추가합니다.

이 방법을 적용하면 쌍을 이루는 구조를 가진 패턴을 분석하고, 중첩된 패턴도 찾을 수 있습니다.

#### 줄 단위 매칭 패턴
마크다운 패턴 중에서 줄 단위를 처리하는 패턴이 있으며, `h1`, `h2` 등 제목 태그와 `blockquote`가 있습니다. 예를 들어, 제목 패턴은 다음과 같이 구성됩니다.

```
### 제목 h3 입니다.
```

이 패턴을 구현하기 위해 특징을 분석하였습니다.
- 시작 문자열로 패턴이 결정되며, 해당 문자열 앞에 다른 문자가 올 수 없습니다.
- 다른 줄 단위 패턴과 중첩될 수 없습니다.
- 패턴 내부에는 다른 문자 단위 매칭 패턴(`strong` 등)이 올 수 있습니다.

이 패턴의 분석 방법은 다른 패턴에 비해 상대적으로 간단합니다. 입력 문자열의 시작점을 확인하면 줄 단위 매칭 패턴인지를 판단할 수 있으며, 이를 통해 텍스트의 구조를 효과적으로 분석할 수 있습니다.

#### 리스트 패턴
마크다운은 리스트 패턴을 지원하며, 리스트는 크게 일반 리스트 `<ul>`와 순서 리스트 `<ol>`로 나뉘며, 각각의 리스트는 내부에 `<li>` 태그를 포함하고 있습니다. 이 패턴은 다른 패턴에 비해 조건이 비교적 복잡합니다.
- 일반 리스트는 문자열의 처음에 '-' 문자가 있어야 하며, 순서 리스트는 각 문자열의 처음에 수가 순서대로 있어야 합니다. (예: '1.', '2.', ...)
- 패턴 조건에 맞는 문자열이 연속적으로 있어야 같은 리스트로 판정됩니다. (두 문자열이 연속적이라는 것은 개행 1번으로 구분되는 두 문자열을 의미합니다.)
- 리스트는 중첩이 될 수 있으며, 중첩된 리스트는 각 리스트 문자 앞에 탭 문자가 중첩된 깊이만큼 있어야 합니다.

아래 예시에서 리스트는 2개 존재하며, 한 리스트가 다른 리스트와 중첩된 구조를 이룹니다.
```
- 리스트 1-1
- 리스트 1-2
	1. 리스트 2-1
	2. 리스트 2-2
	3. 리스트 2-3
- 리스트 1-3
```

중첩된 구조가 존재하므로 `재귀 함수` 호출을 사용하여 설계합니다. 주어진 문자열 목록을 순차 탐색해서 리스트를 판정합니다.
```
현재 문자열이 리스트 패턴을 만족하는지 확인합니다.
- 만족하면 리스트 분석 함수를 호출합니다. (깊이 = 0)

function 리스트 분석(깊이)
1. 다음 문자열이 중첩된 리스트인지 판정합니다.
	- 만족하면 리스트 분석 함수를 호출합니다. (깊이 = 현재 깊이 + 1)
2. 리스트 패턴을 만나지 않을 때까지 다음 문자열을 탐색합니다.
3. 리스트의 끝을 찾으면 리스트의 시작 위치와 끝 위치를 리스트 패턴으로 처리합니다.
```

이 설계를 적용하여 구현한 결과, 일반 리스트와 중첩 리스트를 모두 성공적으로 처리할 수 있었습니다

#### 테이블 패턴
마크다운의 테이블 패턴도 복잡한 편입니다. 테이블의 전체는 `<table>`로 둘러싸여 있으며, 제목 행은 `<thead>`, 제목 이외의 행은 `<tbody>`으로 둘러싸입니다. `<thead>` 내부의 행은 `<th>`, `<tbody>` 내부의 행들은 각각 `<tr>`으로 둘러싸이고, 각 행에 포함된 열 아이템은 `<td>`로 둘러싸입니다. 테이블 패턴의 특징은 다음과 같습니다:
- 테이블의 모든 원소는 '|' 문자로 구분됩니다.
- 테이블의 제목 행은 1개만 존재하며, 테이블의 내용 행은 여러 개 존재할 수 있습니다.
- 각 행의 열 개수는 모두 동일해야 합니다.
- 제목 행과 내용 행 사이에는 구분 행이 존재합니다. 구분 행의 원소 값은 "---"입니다.

아래 예시는 3x3 크기의 테이블입니다.
```
|제목1|제목2|제목3|
|---|---|---|
|값1|값2|값3|
|값4|값5|값6|
```

구분 행을 기준으로 분석하면 테이블 패턴을 찾을 수 있습니다. 주어진 문자열 목록을 순차 탐색해서 테이블을 판별합니다.
```
테이블 판정
1. 현재 문자열이 구분 행인지 판정합니다.
	- "---" 문자열이 문자 '|'로 구분된 구조인지 판정합니다.
	- 현재 열의 개수를 구합니다.
2. 이전 문자열에 대해 제목 행을 판정합니다.
3. 다음 문자열들을 탐색해서 내용 행들을 찾습니다.
	- 행의 구조를 만족하지 않는 문자열을 만날 때까지 탐색합니다.
4. 테이블 패턴을 반영합니다.
```

이 방법을 통해 테이블 패턴을 성공적으로 에디터와 HTML 페이지에 반영할 수 있었습니다.

#### 대형 코드 블록 패턴
코드 블록은 코드를 표현하는 데 특화된 요소입니다. 마크다운의 대형 코드 블록 패턴은 '`' 문자가 3개로 이어진 문자열의 쌍으로 구성됩니다. 문자 단위 매칭 패턴과 유사하게 쌍 구조를 가지지만, 대형 코드 블록 패턴은 문자열 단위로 작동한다는 차이점이 있습니다. 코드 블록 내부에서는 다른 패턴의 효과가 적용되지 않습니다.

이 패턴을 구현하기 위해선 문자열 단위로 탐색할 필요가 있습니다. 또한 내부 중첩을 허용하지 않으므로, 다른 패턴을 탐색하기 전에 대형 코드 블록 패턴을 먼저 분석해야 합니다. 주어진 문자열 목록을 순차 탐색해서 대형 코드 블록 패턴을 판정합니다.
```
1. 현재 문자열이 패턴 문자열인지 확인합니다.
2. 조건을 만족한다면 다음 패턴 문자열을 만족할 때까지 다음 문자열을 탐색합니다.
3. 두 문자열을 모두 찾았다면 대형 코드 블록 패턴을 반영합니다.
```

이 방법을 사용하여 대형 코드 블록 패턴을 성공적으로 구현함으로써 코드 블록을 추가할 수 있었습니다.

#### 이미지 패턴, 링크 패턴
마크다운에서 이미지와 링크 패턴이 존재하며, 각각 `<img>`와 `<a>` 태그와 대응됩니다. 문자 단위 매칭 패턴처럼 한 문자열에서만 존재하지만, 패턴 구조가 다소 복잡합니다.
- 이미지와 링크 패턴은 각각 `![x](y)`,  `[x](y)` 구조인 문자열로 구성됩니다. (x와 y는 각각 텍스트 내용입니다.)
- 텍스트 내용에서는 다른 패턴과 중첩되지 않습니다.

패턴 중첩이 발생하지 않기 때문에 `정규 표현식`을 사용하여 구현을 단순화할 수 있습니다. 정규 표현식을 설계할 때, 링크 패턴을 분석할 때 이미지 패턴을 찾지 않도록 유의합니다.

### 커서 동기화
사용자가 입력할 때마다 에디터의 전체 텍스트가 업데이트되면서 현재 커서의 위치가 초기화되는 문제가 발생합니다. 이 문제를 해결하려면 전체 텍스트가 업데이트될 때, 커서 위치를 원래 위치로 복귀해야 합니다. 따라서 현재 커서의 위치(행과 열)를 알아내고, 이 위치를 통해 커서 위치를 복원하는 방법이 필요합니다.

이 문제는 웹에서 제공하는 `Selection` API를 사용하면 해결할 수 있습니다. `Selection` API는 웹 브라우저에서 사용자가 선택한 텍스트나 요소를 다루는 API입니다. `Range` 객체는 DOM에서 시작 및 끝 범위를 정의하며, 그 범위 내에 노드를 삽입하거나 삭제, 조작할 수 있습니다. 이 API를 활용해서 현재 커서의 행과 열을 찾을 수 있습니다.

```
1. 입력 텍스트를 행 단위로 분할합니다.
2. 입력 텍스트를 복사하여 임시 텍스트를 생성합니다.
3. 임시 텍스트에서 현재 커서 위치에 임시 문자를 삽입합니다.
4. 현재 행 찾기: 임시 문자가 존재하는 행을 만날 때까지 탐색하기
	- 임시 텍스트의 행과 현재 텍스트의 행을 비교해서 길이가 다른 것을 이용
5. 텍스트 시작부터 현재 커서까지 길이 구하기
5. 현재 열 찾기: 현재 커서까지 텍스트 길이에서 1번 행과 현재 행의 길이 총합 빼기
```

이 방법을 사용하면 현재 커서의 행과 열을 구할 수 있습니다. 다음으로 커서 위치를 설정하는 방법을 구현합시다. 먼저 에디터 텍스트를 재구성하는 과정에서 커서 위치를 포함하는 노드를 찾습니다. 그리고 찾은 노드를 대상으로 Selection API를 사용하면 커서의 위치를 설정할 수 있습니다.

최종적으로 에디터 업데이트가 발생하더라도 커서의 위치가 정상적으로 유지됩니다. 이 방법을 통해, 사용자는 텍스트 입력 시 커서 위치가 초기화되지 않고 유지되므로 에디터를 더 원활하게 사용할 수 있습니다.

### 한글 입력
사용자가 입력할 때마다 에디터의 전체 텍스트가 업데이트되면 현재 커서 위치가 변동되면서 입력 조합 상태가 초기화됩니다. 구체적으로, 한글을 입력하면 한글이 분해되어 따로 입력되는 문제가 발생합니다. 이 문제를 해결하려면 한글에서 글자가 완성될 때만 에디터가 업데이트되어야 합니다. (한글이 입력될 때는 마크다운 패턴이 추가되지 않으므로 업데이트가 발생하지 않아도 됩니다.)

이 문제는 `inputType` 속성을 사용하면 해결할 수 있습니다. 만약 `inputType`이 `insertCompositionText`이라면 한글과 같은 조합 입력이 발생했다는 의미입니다. 이 때는 에디터 업데이트를 발생하지 않도록 합니다. 만약 한글 조합의 입력이 끝나서 글자 하나가 완성된 입력이라면 `inputType`이 `onCompositionEnd` 값을 가지며, 이 경우는 에디터 업데이트를 발생하도록 합니다.

이제 에디터에서 한글을 입력할 때 글자가 분해되지 않고 정상적으로 입력됩니다.

### 리스트 입력 도우미 시스템
리스트는 여러 개의 아이템을 갖습니다. 만약 사용자가 여러 아이템을 입력한다면, 각 문자열 앞에 '-'를 추가해야 할 것입니다. 이 과정을 돕기 위해 에디터에서 앞 문자열이 리스트라면 사용자가 개행을 수행할 때 리스트의 패턴 문자열을 추가하면 편리할 것입니다.

이 기능의 과정은 다음과 같습니다:
1. 사용자가 개행을 입력합니다.
2. 앞의 문자열이 리스트라면, 해당 리스트의 다음 아이템에 대응하는 패턴을 입력 텍스트에 삽입합니다.
3. 변경된 텍스트를 기준으로 에디터 업데이트를 수행합니다.

이 문제를 해결하기 위해 먼저 사용자가 개행을 입력했는지를 판정해야 합니다. 이는 `inputType` 속성을 사용해서 해결할 수 있습니다.  만약 `inputType`가 `insertParagraph`이라면 개행이 입력되었다는 것을 의미합니다.

개행 판정을 확인했다면, 알맞은 패턴 문자열을 삽입해야 합니다. 이를 구현하려면 각 행의 상태를 알아야 합니다. 이전 행이 리스트이고 현재 행이 몇 번째 행인지 안다면, 알맞은 행의 패턴 문자열을 알 수 있습니다. (예: 현재 행이 숫자 리스트의 4번째 아이템이라면 "4. "를 삽입)

이 기능을 적용함으로써 리스트의 입력이 이전보다 편리해졌습니다.

### 되돌리기(undo) / 복원하기(redo)
사용자가 텍스트를 입력할 때, 입력 텍스트를 이전 상태로 되돌리는 기능을 원할 수 있습니다. 그러므로 텍스트 내용 되돌리기, 복원하기 기능을 구현할 필요가 있습니다.

되돌리는 것과 복원하는 것은 모두 선입선출(FIFO, First In, First Out) 과정이므로, `스택` 자료구조를 활용하면 문제를 해결할 수 있습니다. 작업 내역을 저장하는 "작업 스택"과 작업 내역에서 꺼낸 아이템을 저장하는 "복원 스택"을 정의합니다.
- 일정 시간 동안 입력이 발생하지 않으면, 작업 스택에 현재 텍스트 상태를 저장합니다.
- 되돌리기: 작업 스택의 가장 위 아이템을 가져와서 현재 텍스트 상태를 업데이트합니다. 그리고 복원 스택에 저장합니다.
- 복원하기: 복원 스택의 가장 위 아이템을 가져와서 현재 텍스트 상태를 업데이트합니다. 그리고 작업 스택에 저장합니다.

이 기능을 구현하면 사용자는 되돌리기와 복원하기를 활용할 수 있어 텍스트 입력이 한층 더 편리해집니다.

### 파일 시스템
사용자는 여러 개의 텍스트를 보관할 수 있습니다. 이를 반영하려면 텍스트들을 파일 시스템처럼 관리할 필요가 있습니다. 파일 시스템은 파일과 디렉터리로 구성되어 있으며, 디렉터리는 파일과 다른 디렉터리를 포함할 수 있습니다.

파일 시스템 구현 문제를 해결하기 위해 `트리` 자료구조를 활용하였습니다. 트리의 각 노드는 여러 개의 노드를 자식으로 가질 수 있으므로 디렉터리를 구현하는데 적합합니다. 자식이 없는 노드는 파일에 대응됩니다. 파일 및 디렉터리의 추가는 트리의 노드 추가, 파일 및 디렉터리의 삭제는 트리의 노드 삭제와 같습니다.

트리를 사용하여 파일 시스템을 구현함으로써 사용자는 여러 개의 텍스트를 용이하게 관리할 수 있게 되었습니다.
