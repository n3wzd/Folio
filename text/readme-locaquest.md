# LocaQuest

---

2025-01 ~ 2025-02 (1인)

## 배경
**LocaQuest**는 실시간 위치 기반 서비스를 제공하며, Redis와 Kafka를 활용한 대규모 트래픽 처리 및 실시간 데이터 분석을 통해 사용자에게 경험치, 레벨, 도전 과제 등 게임화된 요소를 제공하고, 마이크로서비스 아키텍처로 높은 성능을 구현하는 위치 기반 게임화 플랫폼입니다.

## 기능
### 1. 지도
사용자의 실제 활동을 집계합니다.
- **지도 UI**: 사용자의 현재 위치를 보여주는 간단한 지도를 표시합니다.
- **이동 거리 계산**: 사용자의 GPS 위치를 이용하여 현재 위치를 기반으로 이동 거리를 집계합니다.
- **걸음 수 추적**: 모바일 센서 기능을 이용하여 실시간으로 사용자의 걸음 수를 집계합니다.

### 2. 사용자 프로필 관리
사용자의 정보와 활동을 관리합니다.
- **회원 가입 및 로그인**: 사용자가 계정을 생성하고, 로그인할 수 있는 기능을 제공합니다.
- **OAuth 2.0 기반 인증**: JWT를 사용하여 인증 및 권한 부여를 처리합니다.
- **이메일 인증**: 회원 가입 및 비밀번호 변경시, 이메일 인증을 요구하여 보안을 높입니다.
- **사용자 프로필 관리**: 사용자는 자신의 프로필을 관리할 수 있습니다. 기본 정보(이름, 이메일 등)를 작성하고, 사용자가 직접 프로필 사진을 업로드할 수 있습니다.

### 3. 게임화 요소 (Gamification)
사용자가 활동하면서 경험치, 레벨, 도전 과제 등을 획득할 수 있도록 하여 사용자의 참여를 유도합니다.
- **경험치 시스템**: 사용자의 활동 데이터를 서버로 보내면 경험치를 제공합니다. 경험치가 올라가면 레벨이 올라갑니다.
- **도전 과제 시스템**: 사용자가 일정 조건을 만족할 때 도전 과제를 달성할 수 있습니다. 획득한 도전 과제는 달성한 과제 목록에 보관됩니다.
- **게임화된 UI**: 경험치 바, 레벨 값을 표시하고 도전 과제 아이콘을 나열하여 사용자의 참여를 유도할 수 있습니다.

### 4. 통계 시각화
사용자 경험치, 걸음수, 이동 거리의 날짜별 통계를 다양한 차트로 시각화하여 제공합니다.
- **활동량 UI**: 사용자의 일별 활동량을 요약하여 표시하는 테이블 UI을 제공합니다.
- **데이터 차트**: 사용자의 활동 데이터를 날짜별로 집계하여 평균/누적량을 시각화하는 차트를 표시합니다.
- **날짜별 쿼리**: 사용자는 원하는 기간에 대하여 경험치, 걸음수, 이동 거리 통계를 볼 수 있습니다.

### 5. 마이크로서비스 (Microservice)
서버를 역할에 따라 구분하여 성능을 향상합니다.
- **중심 서버(Core Server)**:
    - 사용자 정보 관리 REST API 제공 (회원가입, 로그인, 프로필)
    - 데이터베이스(MySQL)와 직접 연결되어 데이터를 영구적으로 저장
    - Kafka의 메시지를 소비하여 실시간으로 사용자 활동 데이터 업데이트
- **활동 서버(Activity Server)**:
    - 사용자 활동 데이터를 실시간으로 수집하고, 캐싱 후 Kafka를 통해 중심 서버로 전송
    - Redis를 활용하여 수집한 활동 데이터 캐싱
    - WebSocket을 통한 실시간 클라이언트 통신

### 6. 실시간 데이터 스트리밍
Redis와 Kafka를 활용하여 실시간으로 발생하는 데이터를 처리하고 분석합니다.
- **Web Socket 통신**: 클라이언트와 서버는 Socket으로 실시간 통신하여 사용자에게 즉각적으로 피드백을 제공합니다.
- **Redis로 데이터 캐싱**: Redis를 사용하여 실시간으로 들어오는 데이터를 집계하여 캐싱합니다.
- **Kafka로 서버 간 통신**: 주기적으로 Kafka를 통해 서버 간 통신하여 활동 데이터를 중심 서버의 DB에 안전하게 저장합니다.

### 7. 데이터베이스 및 서버
사용자 데이터를 안전하게 저장하기 위해 데이터베이스를 활용합니다.
- **MySQL 데이터베이스**: 사용자 정보, 활동 내용, 도전 과제 등을 MySQL에 저장합니다.
- **로깅 시스템**: 서버의 모든 활동에 대해 로그를 기록하여 유지 보수를 용이하게 합니다.
- **테스트 도구**: JUnit, JMeter를 사용하여 서버가 정상적으로 동작하는지 테스트를 수행합니다.

## 스택
### 프론트엔드
- **React Native ()**: 네이티브 모바일 애플리케이션을 개발할 수 있는 프레임워크로, 사용자 친화적인 UI 개발에 적합합니다.
- **Typescript**: JavaScript에 타입을 추가하여 코드의 안정성과 가독성을 높여줍니다.

### 백엔드
- **Spring**: Java 기반의 프레임워크로, 대규모 애플리케이션에 적합하며, 다양한 엔터프라이즈 기능을 지원합니다.
    - **Spring Boot**: Spring 프레임워크를 더 쉽게 설정하고 사용할 수 있게 해주는 프레임워크입니다. 기본적으로 설정이 되어 있어, 애플리케이션을 신속하게 개발할 수 있습니다.
    - **Spring Security**: 인증(Authentication)과 권한 부여(Authorization)를 처리하는 보안 프레임워크입니다. JWT 토큰을 이용한 인증 시스템, OAuth 2.0 인증 등을 지원합니다.
    - **Spring Data JPA**: JPA(Java Persistence API)를 기반으로 한 데이터베이스 작업을 더 간편하게 해주는 라이브러리입니다. 관계형 데이터베이스와 객체를 매핑하여 데이터를 다룰 수 있게 해줍니다.
- **Java**: Spring 프레임워크와 함께 사용되는 객체지향 프로그래밍 언어입니다.
- **Node.js**: JavaScript 런타임 환경으로, 서버 측에서 JavaScript를 실행할 수 있게 해줍니다. 비동기 I/O 모델을 이용해 빠른 데이터 처리 및 서버 성능을 최적화할 수 있으며, 높은 확장성을 제공합니다.
	- **Express.js**: Node.js 위에서 동작하는 웹 애플리케이션 프레임워크로, RESTful API 개발 및 비동기 처리를 효율적으로 처리할 수 있습니다.
- **Typescript**: JavaScript에 타입을 추가하여 코드의 안정성과 가독성을 높여줍니다.

### 데이터베이스
- **MySQL**: 관계형 데이터베이스 관리 시스템(RDBMS)입니다. SQL을 사용하여 데이터를 구조적으로 관리하고, 트랜잭션을 지원하는 등의 특성을 가지고 있습니다.
- **SQLite**: 서버가 없는 로컬 RDBMS로, 경량화된 데이터베이스입니다. 클라이언트 측에서 로컬 데이터베이스를 사용하여, 네트워크 연결 없이 데이터 관리가 가능합니다.
- **Redis**: 오픈 소스 인메모리 데이터베이스로, 데이터 캐싱을 통해 서버 성능을 향상시키고, 자주 조회되는 데이터를 메모리에서 처리하여 효율적인 성능을 제공합니다.

### 대용량 서비스
- **Kafka**: 서버 간 메시지 큐 시스템으로, 비동기적인 통신 및 데이터 스트리밍을 관리합니다. 대량의 실시간 데이터를 안정적으로 전송하고 처리하는 데 적합합니다.

### 테스트 도구
- **JUnit**: Java로 작성된 테스트 프레임워크입니다. Spring 애플리케이션의 단위 테스트를 작성합니다.
- **JMeter**: 서버 성능 테스트 및 부하 테스트 도구입니다. REST API 호출을 시뮬레이션하고, 서버의 처리 능력을 테스트합니다.

## 문제 및 해결
### 대규모 트래픽 시스템 설계
#### Redis: 데이터 캐싱
클라이언트는 사용자가 제어할 수 있기 때문에 데이터가 조작될 수 있습니다. 예를 들어, 경험치 획득량을 전송하는 API가 있을 때, 사용자가 경험치 획득량 값을 임의로 조정하여 이득을 볼 수 있습니다. 클라이언트는 그저 정보를 전송하는 역할만 수행해야 하며, 서버 측에서 데이터를 검증한 뒤에 처리를 해야 합니다. 사용자가 경험치 처리 API를 호출하면, 서버 측에서 전송받은 데이터를 검증하여 데이터베이스에 안전하게 값을 반영할 수 있습니다.

하지만, 경험치 처리 API 요청을 지속적으로 호출하면 서버 부하가 증가할 수 있습니다. 사용자가 걸을 때마다 경험치가 증가하므로 1초마다 약 2번의 요청이 발생한다고 가정했을 때, 동시 접속자가 1000명이면 초당 약 2000번의 요청이 발생하는 것입니다. 또한, 경험치는 사용자의 게임 데이터이므로 클라이언트가 전송한 데이터는 반드시 데이터베이스에 반영되어야 합니다. 정리하면, 초당 약 2000번 요청이 발생하는 **대규모 트래픽을 안전하고 빠르게 처리하는 시스템을 구축**해야 합니다.

이 문제를 해결하기 위해, **Redis**를 도입하였습니다. Redis는 데이터를 메모리에 저장하고 빠르게 읽고 쓸 수 있는 오픈 소스 인메모리 데이터 저장소로, 데이터를 키-값(Key-Value) 구조로 저장하는 비관계형(NoSQL) 데이터베이스입니다. 또한 여러 복구 방법도 탑재되어 데이터의 영속성을 보장할 수 있습니다.

경험치는 정수 타입이므로 합연산이 가능합니다. 즉, 사용자와 날짜가 같은 상황에서 경험치 a 증가와 경험치 b 증가 요청이 왔을 때, a와 b를 각각 데이터베이스에 반영한 것과 a + b를 반영한 것은 동일합니다. 사용자가 경험치 증가 요청을 여러 번 보내면 이를 모두 합산하여 반영하는 것이 데이터베이스의 부하를 줄일 수 있습니다. **Redis를 통해 각 사용자의 날짜별 경험치 증가량을 집계하여 캐싱**하고, 주기적으로 데이터베이스에 접속하여 사용자의 요청을 안전하게 반영할 수 있습니다.

Redis를 도입하여 처리해야 할 연산이 크게 줄어들었습니다. 만약 사용자 1명이 초당 2번의 요청을 하는 상황에서 DB 접속 주기가 20초라면, 20초마다 1번의 DB 연산을 수행합니다. 반면 Redis가 없다면, 20초에 40번의 DB 연산을 수행해야 합니다. Redis를 활용함으로써 **DB 연산 횟수가 40배 감소**하였습니다.

#### 마이크로서비스: 독립적인 애플리케이션
단일 애플리케이션을 운용하는 **모놀리스(Monolith) 구조**는 모든 기능을 통합적으로 관리할 수 있다는 점에서 간단하고 유용합니다. 하지만, 모놀리스 구조는 서버 다운에 취약하다는 약점이 있습니다. 빈번히 호출되는 요청은 서버에 부담이 될 수 있으며, 부득이하게 서버가 다운되는 상황이 벌어지면 경험치 처리 API는 물론 다른 요청들도 처리할 수 없게 됩니다.

이러한 문제를 해결하기 위해 **마이크로서비스(Microservice) 구조**로 변경하기로 했습니다. 마이크로서비스는 애플리케이션을 독립적이고 작은 서비스들로 나누어 개발하는 아키텍처 스타일입니다. 역할 별로 애플리케이션를 구분한다는 점에서, 각 기능별로 유리한 스택을 접목할 수 있고 해당 기능에 집중할 수 있다는 이점이 있습니다.

현재 서버를 클라이언트와 사용자 활동 데이터를 실시간으로 통신하는 **활동 서버**, 사용자 정보 관리 REST API 제공 및 데이터베이스 관리를 담당하는 **중심 서버**로 구분합니다. 다양한 기능을 담당하고 활동 서버는 대규모 애플리케이션 개발에 적합하고 다양한 엔터프라이즈 기능을 지원하는 **Spring**을, 실시간 통신이 중요한 활동 서버는 비동기 I/O 모델을 이용해 빠른 데이터 처리가 가능한 **Node.js**을 채택하였습니다.

두 서버를 구분함으로써 각 서버가 독립적인 역할에 집중하여 유지보수성이 향상되었습니다.

#### WebSocket: 실시간 전송
클라이언트는 초당 2번씩 서버의 API를 호출하므로 호출 빈도가 매우 높으며, 이는 **서버에 큰 부하**를 줄 수 있습니다. HTTP 요청/응답 방식은 상태 유지가 없기 때문에 연결을 매번 열고 닫는 오버헤드가 발생하고, 요청과 응답에 걸리는 시간이 지속적으로 누적되면 성능 저하가 발생할 수 있습니다.

실시간 전송을 효율적으로 처리하기 위해 **웹소켓**을 사용하였습니다. 웹소켓은 클라이언트와 서버 간의 지속적인 연결을 유지하면서 데이터를 주고받을 수 있기 때문에, HTTP 요청/응답 방식보다 효율적입니다. React Native는 WebSocket, Node.js는 ws 라이브러리를 이용하여 웹소켓을 구현하였습니다.

경험치 처리 API를 웹소켓으로 통신하여 데이터 전송의 지연 시간이 줄어들었으며 HTTP의 헤더를 사용하지 않음으로써 **네트워크 대역폭이 절약**되었습니다.

#### Kafka: 비동기 메시지 큐
이제 백엔드는 2개의 서버로 분리되었습니다. 새로운 문제는 두 서버간 통신을 처리하는 것입니다. 활동 서버는 중심 서버로 집계한 사용자의 데이터를 전송하고, 중심 서버는 이 요청을 데이터베이스에 반영해야 합니다. 사용자별로 1개의 요청이지만 여전히 요청 수는 많으며, 만약 동시 이용자가 1000번이라면, 주기적으로 1000번의 데이터베이스 요청이 발생합니다. 이 과정을 **동기적으로 처리한다면 상당한 시간이 소요**되어 성능에 부담이 될 수 있습니다.

이 문제를 해결하기 위해 비동기 메시지 큐, **Kafka**를 도입하였습니다. Kafka는 실시간 데이터를 처리하고 저장하는 시스템 간의 중간 메시지 큐로, 대용량 데이터를 처리할 수 있는 확장성과 내구성이 뛰어납니다. Kafka는 주로 발행/구독 모델을 사용하며, 프로듀서가 데이터를 보내고, 컨슈머가 받아서 처리합니다.

Kafka를 이용하여 서버 간 통신을 설계합니다:
1. 활동 서버 → Kafka: **활동 서버**는 Kafka의 **프로듀서** 역할을 하며, 클라이언트의 요청을 메시지 큐에 보내게 됩니다.
2. Kafka → 중심 서버: **중심 서버**는 Kafka의 **컨슈머** 역할을 하며,주기적으로 큐에 있는 요청들을 꺼내어 처리합니다. 중심 서버는 요청을 하나씩 처리하여 데이터베이스에 반영합니다.

Kafka가 도입되어 두 서버의 안정적인 비동기 통신이 가능하게 되었습니다. 더 이상 활동 서버가 중심 서버에 의해 블로킹(blocking)되지 않음으로써 전반적인 서버 성능이 향상되었습니다.

#### JMeter: 성능 테스트
실제로 Redis, Kafka의 도입으로 인해 서버의 성능이 차이가 있는지 확인하였습니다. JMeter를 사용하여 성능 테스트를 수행해보았습니다. 테스트 대상은 데이터베이스와 직접적으로 연결된 API(모놀리스)와 Redis, Kafka가 적용된 API(마이크로서비스)이며, 두 API가 수행하는 기능은 같습니다.

**입력**: 초당 약 **3,333개의 요청**
- **Number of Threads**: 1000
- **Ramp-up period**: 15
- **Loop Count**: 100

**출력**:
- **Average**: 모놀리스 1647ms → 마이크로서비스 462ms (🔽 **-71.96%**)  
- **Std.Dev.**: 모놀리스 1997.31ms → 마이크로서비스 123.78ms (🔽 **-93.80%**)  
- **Throughput**: 모놀리스 321.5/s → 마이크로서비스 1672.0/s (🔼 **+420.12%**)  
- **Median**: 모놀리스 1420ms → 마이크로서비스 484ms (🔽 **-65.91%**)  
- **Line90%**: 모놀리스 2539ms → 마이크로서비스 550ms (🔽 **-78.34%**)  
- **Line95%**: 모놀리스 5212ms → 마이크로서비스 608ms (🔽 **-88.33%**)  
- **Line99%**: 모놀리스 11171ms → 마이크로서비스 834ms (🔽 **-92.54%**)  
- **min**: 모놀리스 8ms → 마이크로서비스 4ms (🔽 **-50.00%**)  
- **max**: 모놀리스 26786ms → 마이크로서비스 939ms (🔽 **-96.49%**)  

**정리**:
- **Average**: 평균 응답 시간이 72% 감소하여 전반적인 처리 속도가 크게 향상되었습니다.
- **Std.Dev.**: 응답 시간 변동폭이 94% 줄어들어 성능이 더욱 안정적으로 유지되었습니다.
- **Throughput**: 초당 처리 가능한 요청 수가 4배 이상 증가하여 처리량이 크게 향상되었습니다.
- **Median**: 절반 이상의 요청이 66% 더 빠르게 처리되어 평균 성능이 향상되었습니다.
- **Line 90%**: 90%의 요청이 78% 더 빠르게 응답되어 대부분의 요청 속도가 크게 향상되었습니다.
- **Line 95%**: 95%의 요청이 88% 더 빠르게 처리되어 고속 응답이 가능해졌습니다.
- **Line 99%**: 가장 느린 1%의 요청 속도가 93% 개선되어 최악의 경우 성능이 크게 향상되었습니다.
- **min**: 최소 응답 시간이 절반으로 줄어들어 최상의 응답 속도가 향상되었습니다.
- **max**: 최악의 경우 응답 시간이 96% 감소하여 지연이 거의 사라졌습니다.

모놀리스 구조에서 Redis와 Kafka를 도입한 마이크로서비스 구조로 전환하면서 **처리량 증가와 응답 속도의 안정성이 크게 향상**되었으며, 대규모 트래픽을 효율적으로 대처할 수 있었습니다.

### 동시성 문제: 경쟁 조건
Redis에서 사용한 키(key)를 Set에 저장하는 Write 연산과, 이 Set에 저장된 키를 모두 가져오는 Read 연산이 있습니다. Write 연산은 경험치 처리 API를 처리할 때, Read 연산은 사용자들의 경험치 증가량을 메시지 큐로 보낼 때 사용됩니다. 문제는 이 연산들이 모두 Redis의 공유 자원에 대해 비동기로 처리되므로 **동시성 문제**가 잠재되어 있으며, **경쟁 조건을 유발**할 가능성이 존재합니다.

1. Write 연산:
	- 특정 키에 대해 입력 값을 더합니다.
	- Set에 사용한 키를 등록합니다.
2. Read 연산:
	- Set에 저장된 모든 키를 가져오고, Set을 초기화합니다.
	- 가져온 키의 값들을 가져오고 해당 키-값을 삭제합니다.

두 과정에서 사용되는 공유 자원은 Set과 Set에 저장된 키입니다. 이에 대해 2가지 문제가 발생할 수 있습니다:
- Read 연산에서 Set에 저장된 키를 모두 가져온 뒤, Write 연산에서 Set에 새로운 키가 등록됩니다. 이후, 초기화가 되면 새로운 키가 반영되지 않습니다.
- Read 연산에서 키의 값을 가져온 뒤 Write 연산의 더하기 과정이 수행됩니다. 이후, 해당 키-값이 삭제되면 더했던 값이 반영되지 않습니다.

이 문제를 해결하려면 공유 자원에 대한 **원자성**이 보장되어야 합니다. Redis에서 단일 명령은 충돌이 발생하지 않지만, 여러 명령의 경우, 명령 간의 순서는 보장되지 않습니다. 그러나 Redis에서 제공하는 **트랜잭션**을 이용하여 여러 명령의 순서를 보장할 수 있습니다.

Redis에서 Write 연산, Read 연산 단위로 트랜잭션을 구현하여 상호 배제를 적용하였습니다. 30초 동안 1,000,000개의 API 요청을 전송하여 테스트한 결과, **동시성 문제 없이 모든 값들이 정상적으로 DB에 반영**되었습니다.

### 보안
#### JWT
사용자 인증을 위해 적절한 방법을 적용하는 것은 중요합니다. **OAuth 2.0**을 이용해 권한 부여를 관리하고, **JWT**를 사용하여 서버가 상태를 저장할 필요 없이 토큰을 통해 사용자의 인증 상태를 유지하였습니다.

JWT 도입 후, 서버는 JWT의 서명을 검증하여 사용자의 인증을 확인하고, 로그인 상태를 유지하는데 필요한 리소스를 절약할 수 있게 되었습니다.

#### Spring Security
서버에서 사용자 인증과 권한 관리를 수동으로 구현하는 것은 보안 위험을 증가시키고 유지보수가 어려워질 수 있습니다.

이를 개선하기 위해 **Spring Security**를 도입하였습니다. Spring Security는 인증 및 권한 관리 기능을 제공하며, 다양한 보안 요구사항을 해결할 수 있는 모듈입니다. 허가되지 않은 주소는 반드시 인증을 요구하여 보안을 강화하고, 인증 과정을 추상화하여 유지 보수성을 향상하였습니다.

#### 환경 변수
코드 내에서 데이터베이스 접속 정보나 API 키와 같은 민감한 정보가 하드코딩되어 있으면 보안에 심각한 위험을 초래할 수 있습니다.

**환경 변수**를 통해 민감한 정보를 외부 파일에 저장하고, 애플리케이션이 실행될 때 이를 불러와 사용합니다. 이로 인해 코드에서 중요한 정보를 하드코딩하지 않게 되어 보안성이 향상되었습니다. 또한, 다른 환경에서의 설정 변경이 용이해져 유지 보수성이 향상되었습니다.

#### Spring JPA
수작업으로 SQL을 작성할 경우, 유지보수의 어려움과 SQL Injection 공격 등 보안에 취약할 수 있습니다. 

**Spring JPA**를 도입하여 데이터베이스와의 상호작용을 객체지향적으로 처리할 수 있도록 했습니다. SQL 쿼리 대신 객체 모델을 사용하여 데이터를 처리함으로써 코드의 가독성과 유지보수성이 높아졌습니다. 또한 쿼리 자동 생성 및 SQL Injection 예방 기능을 활용하여 보안이 강화되었습니다.

#### 이메일 인증
사용자 계정은 제3자로부터 해킹의 위험성이 숨어있습니다. **이메일 인증**을 통해 사용자 인증을 강화할 필요가 있습니다.

사용자가 회원 가입을 하거나 비밀번호 변경시, 제공한 이메일 주소로 인증 메일을 발송합니다. 메일에서 인증 토큰이 포함된 링크를 클릭하면 인증이 완료됩니다. 이를 통해 사용자의 이메일 주소가 유효하고 실제 소유자임을 확인할 수 있게 되어, 계정 관리의 신뢰성이 높아졌습니다.

### 유지보수
#### 로깅
애플리케이션에서 발생하는 문제를 빠르게 파악하고 해결하기 위해서는 사용자의 행동 및 시스템 상태를 추적하는 **로그 시스템**이 필요합니다.

로그를 일관성 있게 기록하기 위해 로그 포맷을 정하고, 오류 발생 시 로그를 명확한 위치에 기록하여 디버깅 효율성을 높였습니다. 로그에 필요한 정보를 충분히 담고, 시스템에서 발생할 수 있는 다양한 오류 상황을 추적할 수 있도록 하였습니다.

로깅 시스템을 도입한 후, 시스템 상태와 사용자 행동을 효율적으로 추적할 수 있게 되었습니다. 또한, 오류 발생 시 빠르게 원인을 파악할 수 있어 디버깅 시간이 유의미하게 단축되었습니다.

#### 리팩터링
애플리케이션 개발 초기에는 코드가 간단했으나, 프로젝트가 커짐에 따라 코드가 점차 복잡해지고 유지보수가 어려워졌습니다. 특히, 비즈니스 로직과 API 호출 로직이 서로 얽혀 있어 코드의 명확성이 떨어지고 오류가 발생할 확률이 높았습니다.

파일 구조를 명확하게 분리하고, 각 컴포넌트의 책임을 명확히 구분하여 코드의 가독성을 높였습니다. 또한, 예외 처리와 API 코드의 분리를 통해 각 기능의 독립성을 강화했습니다. 리팩터링 후, 코드 길이가 약 30% 감소하였고, 코드 생산성과 유지보수성이 향상되었습니다.
